import subprocess
import json
import tempfile
import os
from typing import List, Dict, Any
import requests
import logging
import shutil

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    def __init__(self, available_tools=None):
        self.available_tools = available_tools or {}
        self.scanner_used = "None"  # Start as string instead of list
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"  # Added missing attribute
    
    def scan_sbom(self, sbom_data: Dict, file_path: str) -> List[Dict]:
        """Scan SBOM using available scanners with fallback strategy"""
        vulnerabilities = []
        scanners_used = []  # Use local list to track scanners
        
        # Try Grype first if available
        if self.available_tools.get('grype', False):
            try:
                grype_results = self.scan_with_grype(file_path)
                if grype_results:
                    vulnerabilities.extend(grype_results)
                    scanners_used.append('grype')
                    logger.info(f"‚úÖ Grype found {len(grype_results)} vulnerabilities")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Grype scan failed: {e}")
        
        # Try OWASP Dependency-Check if available
        if self.available_tools.get('dependency-check', False) and not vulnerabilities:
            try:
                depcheck_results = self.scan_with_dependency_check(file_path)
                if depcheck_results:
                    vulnerabilities.extend(depcheck_results)
                    scanners_used.append('dependency-check')
                    logger.info(f"‚úÖ Dependency-Check found {len(depcheck_results)} vulnerabilities")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Dependency-Check scan failed: {e}")
        
        # Fallback to NVD API
        if not vulnerabilities:
            try:
                nvd_results = self.scan_with_nvd_api(sbom_data)
                if nvd_results:
                    vulnerabilities.extend(nvd_results)
                    scanners_used.append('nvd-api')
                    logger.info(f"‚úÖ NVD API found {len(nvd_results)} vulnerabilities")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è NVD API scan failed: {e}")
        
        # Final fallback: mock data
        if not vulnerabilities:
            mock_results = self.mock_scan(sbom_data)
            vulnerabilities.extend(mock_results)
            scanners_used.append('mock')
            logger.info(f"‚ö†Ô∏è Mock scanner found {len(mock_results)} vulnerabilities")
        
        # Deduplicate vulnerabilities
        vulnerabilities = self.deduplicate_vulnerabilities(vulnerabilities)
        
        # Record which scanners were used
        self.scanner_used = ", ".join(scanners_used) if scanners_used else "None"
        
        logger.info(f"üìä Total vulnerabilities found: {len(vulnerabilities)}")
        logger.info(f"üîß Scanners used: {self.scanner_used}")
        
        return vulnerabilities
    
    def scan_with_grype(self, sbom_file_path: str) -> List[Dict]:
        """Scan using Grype"""
        try:
            logger.info(f"üîç Scanning with Grype: {sbom_file_path}")
            
            # Create temporary output file
            with tempfile.NamedTemporaryFile(mode='w+', suffix='.json', delete=False) as temp_file:
                temp_path = temp_file.name
            
            try:
                result = subprocess.run([
                    'grype', f'sbom:{sbom_file_path}', 
                    '--output', 'json',
                    '--file', temp_path,
                    '--add-cpes-if-none'
                ], capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    with open(temp_path, 'r') as f:
                        grype_data = json.load(f)
                    vulnerabilities = self.process_grype_results(grype_data)
                    return vulnerabilities
                else:
                    raise Exception(f"Grype failed: {result.stderr}")
            finally:
                # Clean up temp file
                if os.path.exists(temp_path):
                    os.remove(temp_path)
                    
        except subprocess.TimeoutExpired:
            raise Exception("Grype scan timed out")
        except Exception as e:
            raise Exception(f"Grype error: {str(e)}")
    
    def scan_with_dependency_check(self, sbom_file_path: str) -> List[Dict]:
        """Scan using OWASP Dependency-Check"""
        try:
            logger.info(f"üîç Scanning with OWASP Dependency-Check: {sbom_file_path}")
            
            # Find dependency-check executable
            dc_path = None
            possible_paths = [
                'dependency-check.sh',
                'dependency-check',
                '/usr/bin/dependency-check.sh',
                '/usr/local/bin/dependency-check.sh',
                os.path.expanduser('~/bin/dependency-check.sh')
            ]
            
            for path in possible_paths:
                if shutil.which(path):
                    dc_path = path
                    break
            
            if not dc_path:
                raise Exception("Dependency-Check executable not found")
            
            # Create temporary output directory
            with tempfile.TemporaryDirectory() as temp_dir:
                result = subprocess.run([
                    dc_path,
                    '--scan', sbom_file_path,
                    '--format', 'JSON',
                    '--out', temp_dir,
                    '--project', 'SBOM Analysis',
                    '--enableExperimental'
                ], capture_output=True, text=True, timeout=600)  # Longer timeout for Dependency-Check
                
                if result.returncode == 0:
                    report_path = os.path.join(temp_dir, 'dependency-check-report.json')
                    if os.path.exists(report_path):
                        with open(report_path, 'r') as f:
                            depcheck_data = json.load(f)
                        vulnerabilities = self.process_depcheck_results(depcheck_data)
                        return vulnerabilities
                
                raise Exception(f"Dependency-Check failed: {result.stderr}")
                
        except Exception as e:
            raise Exception(f"Dependency-Check error: {str(e)}")
    
    def scan_with_nvd_api(self, sbom_data: Dict) -> List[Dict]:
        """Fallback to NVD API for known components"""
        vulnerabilities = []
        
        for component in sbom_data.get('components', []):
            comp_name = component.get('name', '')
            comp_version = component.get('version', '')
            
            # Search for CVEs related to this component
            try:
                response = requests.get(
                    f"{self.nvd_api_base}?keywordSearch={comp_name} {comp_version}",
                    timeout=15,
                    headers={'User-Agent': 'CERT-In-SBOM-Tool/1.0'}
                )
                if response.status_code == 200:
                    nvd_data = response.json()
                    for vuln in nvd_data.get('vulnerabilities', []):
                        cve_data = vuln.get('cve', {})
                        vulnerabilities.append({
                            'cve_id': cve_data.get('id', ''),
                            'severity': self.get_severity_from_cvss(cve_data),
                            'description': self.get_description(cve_data),
                            'cvss_score': self.get_cvss_score(cve_data),
                            'fixed_versions': [],
                            'component_name': comp_name,
                            'component_version': comp_version,
                            'vex_status': 'Under Investigation',
                            'scanner': 'NVD API'
                        })
            except Exception as e:
                logger.warning(f"Error querying NVD for {comp_name}: {e}")
                continue
        
        return vulnerabilities
    
    def process_grype_results(self, grype_data: Dict) -> List[Dict]:
        vulnerabilities = []
        
        for match in grype_data.get('matches', []):
            vuln = match.get('vulnerability', {})
            artifact = match.get('artifact', {})
            
            # Convert GHSA to CVE if possible
            vuln_id = vuln.get('id', '')
            if vuln_id.startswith('GHSA-'):
                vuln_id = self.ghsa_to_cve(vuln_id) or vuln_id
            
            vulnerability = {
                'cve_id': vuln_id,  # Use converted ID
                'severity': vuln.get('severity', 'Unknown').capitalize(),
                'description': vuln.get('description', 'No description available'),
                'cvss_score': self.get_cvss_score(vuln),
                'fixed_versions': self.get_fixed_versions(vuln),
                'component_name': artifact.get('name', ''),
                'component_version': artifact.get('version', ''),
                'vex_status': 'Under Investigation',
                'scanner': 'Grype'
            }
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def ghsa_to_cve(self, ghsa_id: str) -> str:
        """Convert GitHub Security Advisory ID to CVE ID"""
        # Common GHSA to CVE mappings
        ghsa_to_cve_map = {
            'GHSA-jfh8-c2jp-5v3q': 'CVE-2023-38545',
            'GHSA-xxxx-xxxx-xxxx': 'CVE-2023-xxxxx',
            # Add more mappings as needed
        }
        
        # Try to fetch from GitHub API if not in local map
        if ghsa_id not in ghsa_to_cve_map:
            try:
                response = requests.get(
                    f'https://api.github.com/advisories/{ghsa_id}',
                    headers={'Accept': 'application/vnd.github+json'},
                    timeout=5
                )
                if response.status_code == 200:
                    data = response.json()
                    if 'cve_id' in data and data['cve_id']:
                        return data['cve_id']
            except Exception:
                pass
        
        return ghsa_to_cve_map.get(ghsa_id, ghsa_id)  # Fallback to original ID
    
    def process_depcheck_results(self, depcheck_data: Dict) -> List[Dict]:
        """Process OWASP Dependency-Check results"""
        vulnerabilities = []
        
        for dependency in depcheck_data.get('dependencies', []):
            for vuln in dependency.get('vulnerabilities', []):
                vulnerabilities.append({
                    'cve_id': vuln.get('name', ''),
                    'severity': vuln.get('severity', 'Unknown').capitalize(),
                    'description': vuln.get('description', 'No description available'),
                    'cvss_score': float(vuln.get('cvssScore', 0)),
                    'fixed_versions': [],
                    'component_name': dependency.get('fileName', ''),
                    'component_version': dependency.get('version', ''),
                    'vex_status': 'Under Investigation',
                    'scanner': 'Dependency-Check'
                })
        
        return vulnerabilities
    
    def get_severity_from_cvss(self, cve_data: Dict) -> str:
        """Extract severity from CVSS data"""
        metrics = cve_data.get('metrics', {})
        if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
            return metrics['cvssMetricV31'][0].get('cvssData', {}).get('baseSeverity', 'Unknown')
        elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
            # Convert CVSS v2 base score to severity
            base_score = float(metrics['cvssMetricV2'][0].get('cvssData', {}).get('baseScore', 0))
            if base_score >= 7.0: return 'High'
            elif base_score >= 4.0: return 'Medium'
            else: return 'Low'
        return 'Unknown'
    
    def get_description(self, cve_data: Dict) -> str:
        """Extract description from CVE data"""
        descriptions = cve_data.get('descriptions', [])
        for desc in descriptions:
            if desc.get('lang') == 'en':
                return desc.get('value', 'No description available')
        return 'No description available'
    
    def get_cvss_score(self, vuln: Dict) -> float:
        for rating in vuln.get('cvss', []):
            if 'metrics' in rating:
                return rating['metrics'].get('baseScore', 0.0)
        return 0.0
    
    def get_fixed_versions(self, vuln: Dict) -> List[str]:
        fix = vuln.get('fix', {})
        return fix.get('versions', [])
    
    def deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Remove duplicate vulnerabilities based on CVE ID and component"""
        seen = set()
        deduplicated = []
        
        for vuln in vulnerabilities:
            key = (vuln['cve_id'], vuln['component_name'], vuln['component_version'])
            if key not in seen:
                seen.add(key)
                deduplicated.append(vuln)
        
        return deduplicated
    
    def mock_scan(self, sbom_data: Dict) -> List[Dict]:
        """Mock scanner as final fallback"""
        logger.info("‚ö†Ô∏è Using mock scanner as final fallback")
        vulnerabilities = []
        
        # Sample vulnerabilities for common components
        mock_vulnerabilities = {
            'log4j': {
                'CVE-2021-44228': {
                    'severity': 'Critical',
                    'description': 'Apache Log4j2 JNDI features vulnerability',
                    'cvss_score': 10.0,
                    'fixed_versions': ['2.15.0', '2.16.0']
                }
            },
            'spring': {
                'CVE-2022-22965': {
                    'severity': 'High',
                    'description': 'Spring Framework RCE via Data Binding',
                    'cvss_score': 8.1,
                    'fixed_versions': ['5.3.18', '5.2.20']
                }
            },
            'openssl': {
                'CVE-2022-3602': {
                    'severity': 'High', 
                    'description': 'X.509 Email Address Buffer Overflow',
                    'cvss_score': 7.5,
                    'fixed_versions': ['3.0.7']
                }
            },
            'tomcat': {
                'CVE-2020-1938': {
                    'severity': 'High',
                    'description': 'Apache Tomcat AJP File Read/Inclusion Vulnerability',
                    'cvss_score': 7.5,
                    'fixed_versions': ['9.0.31', '8.5.51', '7.0.100']
                }
            }
        }
        
        for component in sbom_data.get('components', []):
            comp_name = component.get('name', '').lower()
            comp_version = component.get('version', '')
            
            # Check if component matches any known vulnerable components
            for pattern, vulns in mock_vulnerabilities.items():
                if pattern in comp_name:
                    for cve_id, vuln_data in vulns.items():
                        vulnerabilities.append({
                            'cve_id': cve_id,
                            'severity': vuln_data['severity'],
                            'description': vuln_data['description'],
                            'cvss_score': vuln_data['cvss_score'],
                            'fixed_versions': vuln_data['fixed_versions'],
                            'component_name': component.get('name'),
                            'component_version': comp_version,
                            'vex_status': 'Under Investigation',
                            'scanner': 'Mock'
                        })
        
        logger.info(f"‚ö†Ô∏è Mock scanner found {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities

# Global scanner instance
scanner = VulnerabilityScanner()

# For backward compatibility
def scan_sbom_with_grype(sbom_data, file_path):
    return scanner.scan_sbom(sbom_data, file_path)
