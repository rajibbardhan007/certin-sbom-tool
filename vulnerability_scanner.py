import subprocess
import json
import tempfile
import os
from typing import List, Dict, Any
import requests
import logging
import shutil

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    def __init__(self, available_tools=None):
        self.available_tools = available_tools or {}
        self.scanner_used = "None"
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.ghsa_to_cve_cache = {}
    
    def scan_sbom(self, sbom_data: Dict, file_path: str) -> List[Dict]:
        """Scan SBOM using available scanners with fallback strategy"""
        vulnerabilities = []
        scanners_used = []
        
        # Try Grype first if available
        if self.available_tools.get('grype', False):
            try:
                grype_results = self.scan_with_grype(file_path)
                if grype_results:
                    vulnerabilities.extend(grype_results)
                    scanners_used.append('grype')
                    logger.info(f"‚úÖ Grype found {len(grype_results)} vulnerabilities")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Grype scan failed: {e}")
        
        # Try OWASP Dependency-Check if available
        if self.available_tools.get('dependency-check', False) and not vulnerabilities:
            try:
                depcheck_results = self.scan_with_dependency_check(file_path)
                if depcheck_results:
                    vulnerabilities.extend(depcheck_results)
                    scanners_used.append('dependency-check')
                    logger.info(f"‚úÖ Dependency-Check found {len(depcheck_results)} vulnerabilities")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Dependency-Check scan failed: {e}")
        
        # Fallback to NVD API
        if not vulnerabilities:
            try:
                nvd_results = self.scan_with_nvd_api(sbom_data)
                if nvd_results:
                    vulnerabilities.extend(nvd_results)
                    scanners_used.append('nvd-api')
                    logger.info(f"‚úÖ NVD API found {len(nvd_results)} vulnerabilities")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è NVD API scan failed: {e}")
        
        # Final fallback: mock data
        if not vulnerabilities:
            mock_results = self.mock_scan(sbom_data)
            vulnerabilities.extend(mock_results)
            scanners_used.append('mock')
            logger.info(f"‚ö†Ô∏è Mock scanner found {len(mock_results)} vulnerabilities")
        
        # Deduplicate vulnerabilities
        vulnerabilities = self.deduplicate_vulnerabilities(vulnerabilities)
        
        # Convert all GHSA IDs to CVE IDs
        vulnerabilities = self.convert_ghsa_to_cve(vulnerabilities)
        
        if scanners_used:
            self.scanner_used = ", ".join(scanners_used)
        else:
            self.scanner_used = "None"
        
        logger.info(f"üìä Total vulnerabilities found: {len(vulnerabilities)}")
        logger.info(f"üîß Scanners used: {self.scanner_used}")
        
        return vulnerabilities
    
    def convert_ghsa_to_cve(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Convert all GHSA IDs to CVE IDs in vulnerabilities list"""
        converted_vulnerabilities = []
        
        for vuln in vulnerabilities:
            vuln_id = vuln.get('cve_id', '')
            if vuln_id.startswith('GHSA-'):
                cve_id = self.ghsa_to_cve(vuln_id)
                if cve_id and cve_id != vuln_id:
                    logger.info(f"üîÅ Converted GHSA {vuln_id} to CVE {cve_id}")
                    vuln['cve_id'] = cve_id
                elif cve_id is None:
                    logger.warning(f"‚ö†Ô∏è Could not convert GHSA {vuln_id} to CVE")
            
            converted_vulnerabilities.append(vuln)
        
        return converted_vulnerabilities
    
    def scan_with_grype(self, sbom_file_path: str) -> List[Dict]:
        """Scan using Grype"""
        try:
            logger.info(f"üîç Scanning with Grype: {sbom_file_path}")
            
            with tempfile.NamedTemporaryFile(mode='w+', suffix='.json', delete=False) as temp_file:
                temp_path = temp_file.name
            
            try:
                result = subprocess.run([
                    'grype', f'sbom:{sbom_file_path}', 
                    '--output', 'json',
                    '--file', temp_path,
                    '--add-cpes-if-none'
                ], capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    with open(temp_path, 'r') as f:
                        grype_data = json.load(f)
                    vulnerabilities = self.process_grype_results(grype_data)
                    return vulnerabilities
                else:
                    raise Exception(f"Grype failed: {result.stderr}")
            finally:
                if os.path.exists(temp_path):
                    os.remove(temp_path)
                    
        except subprocess.TimeoutExpired:
            raise Exception("Grype scan timed out")
        except Exception as e:
            raise Exception(f"Grype error: {str(e)}")
    
    def scan_with_dependency_check(self, sbom_file_path: str) -> List[Dict]:
        """Scan using OWASP Dependency-Check"""
        try:
            logger.info(f"üîç Scanning with OWASP Dependency-Check: {sbom_file_path}")
            
            dc_path = None
            possible_paths = [
                'dependency-check.sh', 'dependency-check',
                '/usr/bin/dependency-check.sh', '/usr/local/bin/dependency-check.sh'
            ]
            
            for path in possible_paths:
                if shutil.which(path):
                    dc_path = path
                    break
            
            if not dc_path:
                raise Exception("Dependency-Check executable not found")
            
            with tempfile.TemporaryDirectory() as temp_dir:
                result = subprocess.run([
                    dc_path,
                    '--scan', sbom_file_path,
                    '--format', 'JSON',
                    '--out', temp_dir,
                    '--project', 'SBOM Analysis',
                    '--enableExperimental'
                ], capture_output=True, text=True, timeout=600)
                
                if result.returncode == 0:
                    report_path = os.path.join(temp_dir, 'dependency-check-report.json')
                    if os.path.exists(report_path):
                        with open(report_path, 'r') as f:
                            depcheck_data = json.load(f)
                        vulnerabilities = self.process_depcheck_results(depcheck_data)
                        return vulnerabilities
                
                raise Exception(f"Dependency-Check failed: {result.stderr}")
                
        except Exception as e:
            raise Exception(f"Dependency-Check error: {str(e)}")
    
    def scan_with_nvd_api(self, sbom_data: Dict) -> List[Dict]:
        """Fallback to NVD API for known components"""
        vulnerabilities = []
        
        for component in sbom_data.get('components', []):
            comp_name = component.get('name', '')
            comp_version = component.get('version', '')
            
            try:
                response = requests.get(
                    f"{self.nvd_api_base}?keywordSearch={comp_name} {comp_version}",
                    timeout=15,
                    headers={'User-Agent': 'CERT-In-SBOM-Tool/1.0'}
                )
                if response.status_code == 200:
                    nvd_data = response.json()
                    for vuln in nvd_data.get('vulnerabilities', []):
                        cve_data = vuln.get('cve', {})
                        vulnerabilities.append({
                            'cve_id': cve_data.get('id', ''),
                            'severity': self.get_severity_from_cvss(cve_data),
                            'description': self.get_description(cve_data),
                            'cvss_score': self.get_cvss_score(cve_data),
                            'fixed_versions': [],
                            'component_name': comp_name,
                            'component_version': comp_version,
                            'vex_status': 'Under Investigation',
                            'scanner': 'NVD API'
                        })
            except Exception as e:
                logger.warning(f"Error querying NVD for {comp_name}: {e}")
                continue
        
        return vulnerabilities
    
    def process_grype_results(self, grype_data: Dict) -> List[Dict]:
        vulnerabilities = []
        
        for match in grype_data.get('matches', []):
            vuln = match.get('vulnerability', {})
            artifact = match.get('artifact', {})
            
            vulnerability = {
                'cve_id': vuln.get('id', ''),
                'severity': vuln.get('severity', 'Unknown').capitalize(),
                'description': vuln.get('description', 'No description available'),
                'cvss_score': self.get_cvss_score(vuln),
                'fixed_versions': self.get_fixed_versions(vuln),
                'component_name': artifact.get('name', ''),
                'component_version': artifact.get('version', ''),
                'vex_status': 'Under Investigation',
                'scanner': 'Grype'
            }
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def ghsa_to_cve(self, ghsa_id: str) -> str:
        """Convert GitHub Security Advisory ID to CVE ID with caching"""
        if ghsa_id in self.ghsa_to_cve_cache:
            return self.ghsa_to_cve_cache[ghsa_id]
        
        # Common GHSA to CVE mappings
        ghsa_to_cve_map = {
            'GHSA-jfh8-c2jp-5v3q': 'CVE-2023-38545',
            'GHSA-7rjr-3q55-vv33': 'CVE-2023-38546',
            'GHSA-j544-7q9p-6xp8': 'CVE-2023-12345',  # Example mapping
            'GHSA-pw8h-wq6x-3x2g': 'CVE-2023-23456',  # Example mapping
        }
        
        # Check local map first
        if ghsa_id in ghsa_to_cve_map:
            self.ghsa_to_cve_cache[ghsa_id] = ghsa_to_cve_map[ghsa_id]
            return ghsa_to_cve_map[ghsa_id]
        
        # Try to fetch from GitHub API
        try:
            response = requests.get(
                f'https://api.github.com/advisories/{ghsa_id}',
                headers={'Accept': 'application/vnd.github+json'},
                timeout=5
            )
            if response.status_code == 200:
                data = response.json()
                if 'cve_id' in data and data['cve_id']:
                    self.ghsa_to_cve_cache[ghsa_id] = data['cve_id']
                    return data['cve_id']
        except Exception:
            pass
        
        # If no CVE found, return the original GHSA ID
        self.ghsa_to_cve_cache[ghsa_id] = ghsa_id
        return ghsa_id
    
    def process_depcheck_results(self, depcheck_data: Dict) -> List[Dict]:
        """Process OWASP Dependency-Check results"""
        vulnerabilities = []
        
        for dependency in depcheck_data.get('dependencies', []):
            for vuln in dependency.get('vulnerabilities', []):
                vuln_id = vuln.get('name', '')
                # Convert GHSA to CVE if needed
                if vuln_id.startswith('GHSA-'):
                    vuln_id = self.ghsa_to_cve(vuln_id)
                
                vulnerabilities.append({
                    'cve_id': vuln_id,
                    'severity': vuln.get('severity', 'Unknown').capitalize(),
                    'description': vuln.get('description', 'No description available'),
                    'cvss_score': float(vuln.get('cvssScore', 0)),
                    'fixed_versions': [],
                    'component_name': dependency.get('fileName', ''),
                    'component_version': dependency.get('version', ''),
                    'vex_status': 'Under Investigation',
                    'scanner': 'Dependency-Check'
                })
        
        return vulnerabilities
    
    def get_severity_from_cvss(self, cve_data: Dict) -> str:
        """Extract severity from CVSS data"""
        metrics = cve_data.get('metrics', {})
        if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
            return metrics['cvssMetricV31'][0].get('cvssData', {}).get('baseSeverity', 'Unknown')
        elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
            base_score = float(metrics['cvssMetricV2'][0].get('cvssData', {}).get('baseScore', 0))
            if base_score >= 7.0: return 'High'
            elif base_score >= 4.0: return 'Medium'
            else: return 'Low'
        return 'Unknown'
    
    def get_description(self, cve_data: Dict) -> str:
        """Extract description from CVE data"""
        descriptions = cve_data.get('descriptions', [])
        for desc in descriptions:
            if desc.get('lang') == 'en':
                return desc.get('value', 'No description available')
        return 'No description available'
    
    def get_cvss_score(self, vuln: Dict) -> float:
        for rating in vuln.get('cvss', []):
            if 'metrics' in rating:
                return rating['metrics'].get('baseScore', 0.0)
        return 0.0
    
    def get_fixed_versions(self, vuln: Dict) -> List[str]:
        fix = vuln.get('fix', {})
        return fix.get('versions', [])
    
    def deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Remove duplicate vulnerabilities based on CVE ID and component"""
        seen = set()
        deduplicated = []
        
        for vuln in vulnerabilities:
            key = (vuln['cve_id'], vuln['component_name'], vuln['component_version'])
            if key not in seen:
                seen.add(key)
                deduplicated.append(vuln)
        
        return deduplicated
    
    def mock_scan(self, sbom_data: Dict) -> List[Dict]:
        """Mock scanner as final fallback"""
        logger.info("‚ö†Ô∏è Using mock scanner as final fallback")
        vulnerabilities = []
        
        mock_vulnerabilities = {
            'log4j': {
                'CVE-2021-44228': {
                    'severity': 'Critical',
                    'description': 'Apache Log4j2 JNDI features vulnerability',
                    'cvss_score': 10.0,
                    'fixed_versions': ['2.15.0', '2.16.0']
                }
            },
            'spring': {
                'CVE-2022-22965': {
                    'severity': 'High',
                    'description': 'Spring Framework RCE via Data Binding',
                    'cvss_score': 8.1,
                    'fixed_versions': ['5.3.18', '5.2.20']
                }
            }
        }
        
        for component in sbom_data.get('components', []):
            comp_name = component.get('name', '').lower()
            comp_version = component.get('version', '')
            
            for pattern, vulns in mock_vulnerabilities.items():
                if pattern in comp_name:
                    for cve_id, vuln_data in vulns.items():
                        vulnerabilities.append({
                            'cve_id': cve_id,
                            'severity': vuln_data['severity'],
                            'description': vuln_data['description'],
                            'cvss_score': vuln_data['cvss_score'],
                            'fixed_versions': vuln_data['fixed_versions'],
                            'component_name': component.get('name'),
                            'component_version': comp_version,
                            'vex_status': 'Under Investigation',
                            'scanner': 'Mock'
                        })
        
        logger.info(f"‚ö†Ô∏è Mock scanner found {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities

# Global scanner instance
scanner = VulnerabilityScanner()
